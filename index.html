<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Simple WebRTC Voice 1-to-1 Demo</title>
    <style>
      body {
        font-family: Inter, system-ui, Segoe UI, Arial;
        margin: 24px;
      }
      .card {
        max-width: 720px;
        margin: 0 auto;
        border: 1px solid #eee;
        padding: 18px;
        border-radius: 8px;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.03);
      }
      label {
        display: block;
        margin-top: 8px;
      }
      input,
      button {
        padding: 8px 12px;
        font-size: 15px;
      }
      .row {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }
      #log {
        white-space: pre-wrap;
        background: #fafafa;
        border: 1px solid #eee;
        padding: 10px;
        height: 140px;
        overflow: auto;
        margin-top: 12px;
      }
    </style>
  </head>
  <body>
    <div class="card">
      <h2>WebRTC Voice 1-to-1 (Signaling via WebSocket)</h2>
      <p>
        Enter a room name (same on both tabs/devices). Allow microphone when
        prompted. One side clicks <strong>Call</strong>, the other sees an
        incoming call button <strong>Accept</strong>.
      </p>

      <label
        >Signaling server (default uses same host):
        <input
          id="serverUrl"
          value="wss://discovering-webrtc.onrender.com"
          style="width: 100%"
        />
      </label>

      <label
        >Room name:
        <input id="room" placeholder="room123" style="width: 100%" />
      </label>

      <div class="row">
        <button id="joinBtn">Join Room</button>
        <button id="callBtn" disabled>Call</button>
        <button id="hangBtn" disabled>Hang up</button>
      </div>

      <div id="incoming" style="margin-top: 12px; display: none">
        <strong>Incoming call</strong>
        <div class="row">
          <button id="acceptBtn">Accept</button>
          <button id="rejectBtn">Reject</button>
        </div>
      </div>

      <h4>Local / Remote</h4>
      <p>
        <strong>Local mic:</strong> <span id="localState">not started</span
        ><br />
        <strong>Remote audio:</strong> <span id="remoteState">no stream</span>
      </p>

      <audio id="remoteAudio" autoplay playsinline></audio>

      <div id="log"></div>
    </div>
  </body>
  <script>
    // Minimal WebRTC voice 1-to-1 client
    let localStream = null;
    let pc = null;
    let ws = null;
    let room = null;
    let isCaller = false;
    let remoteAudio = document.getElementById('remoteAudio');

    const logEl = document.getElementById('log');
    function log(...args) {
      console.log(...args);
      logEl.textContent +=
        args
          .map((a) => (typeof a === 'object' ? JSON.stringify(a) : String(a)))
          .join(' ') + '\n';
      logEl.scrollTop = logEl.scrollHeight;
    }

    const serverUrlInput = document.getElementById('serverUrl');
    const roomInput = document.getElementById('room');
    const joinBtn = document.getElementById('joinBtn');
    const callBtn = document.getElementById('callBtn');
    const hangBtn = document.getElementById('hangBtn');
    const incomingDiv = document.getElementById('incoming');
    const acceptBtn = document.getElementById('acceptBtn');
    const rejectBtn = document.getElementById('rejectBtn');
    const localState = document.getElementById('localState');
    const remoteState = document.getElementById('remoteState');

    joinBtn.addEventListener('click', async () => {
      const url = serverUrlInput.value.trim();
      room = roomInput.value.trim();
      if (!room) {
        alert('Enter room name');
        return;
      }

      ws = new WebSocket(url);
      ws.addEventListener('open', () => {
        log('WS open');
        ws.send(JSON.stringify({ type: 'join', room }));
        joinBtn.disabled = true;
        callBtn.disabled = false;
      });

      ws.addEventListener('message', async (ev) => {
        const msg = JSON.parse(ev.data);
        log('ws<-', msg);

        if (msg.type === 'joined') {
          log('Joined room', room, 'peers:', msg.peers);
        } else if (msg.type === 'offer') {
          // incoming call
          incomingDiv.style.display = 'block';
          window._incomingOffer = msg; // store until accept
        } else if (msg.type === 'answer') {
          await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
          log('Set remote answer');
        } else if (msg.type === 'candidate') {
          if (pc) {
            try {
              await pc.addIceCandidate(msg.candidate);
              log('Added remote ICE candidate');
            } catch (e) {
              log('Error addIce', e);
            }
          }
        } else if (msg.type === 'leave') {
          log('Peer left');
          cleanup();
        }
      });

      ws.addEventListener('close', () => {
        log('WS closed');
      });
      ws.addEventListener('error', (e) => {
        log('WS error', e);
      });

      // prepare local audio, but don't create offer yet
      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });
        localState.textContent = 'ready';
        log('Local audio ready');
      } catch (e) {
        alert('Microphone permission required: ' + e.message);
        log('getUserMedia failed', e);
      }
    });

    callBtn.addEventListener('click', async () => {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert('Connect signaling first');
        return;
      }
      isCaller = true;
      // must be connection for each Peer Existing
      await startPeerConnection();
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      log('Created offer');
      ws.send(
        JSON.stringify({ type: 'offer', room, sdp: pc.localDescription })
      );
    });

    acceptBtn.addEventListener('click', async () => {
      incomingDiv.style.display = 'none';
      const msg = window._incomingOffer;
      if (!msg) return;
      await startPeerConnection();
      await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
      console.log('sdp is => ', msg.sdp);
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      ws.send(
        JSON.stringify({ type: 'answer', room, sdp: pc.localDescription })
      );
      log('Sent answer');
    });

    rejectBtn.addEventListener('click', () => {
      incomingDiv.style.display = 'none';
      window._incomingOffer = null;
      ws.send(JSON.stringify({ type: 'reject', room }));
    });

    hangBtn.addEventListener('click', () => {
      ws && ws.send(JSON.stringify({ type: 'hangup', room }));
      cleanup();
    });

    async function startPeerConnection() {
      if (pc) return;
      pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          // add TURN here if you have one: {urls:'turn:turn.example.com', username:'u', credential:'p'}
        ],
      });

      pc.onicecandidate = (ev) => {
        if (ev.candidate) {
          log('Local ICE candidate', ev.candidate);
          ws.send(
            JSON.stringify({
              type: 'candidate',
              room,
              candidate: ev.candidate,
            })
          );
        }
      };

      pc.ontrack = (ev) => {
        log('Remote track', ev.streams);
        remoteAudio.srcObject = ev.streams[0];
        remoteState.textContent = 'playing';
      };

      // add local audio track
      if (localStream) {
        for (const t of localStream.getTracks()) pc.addTrack(t, localStream);
      } else {
        try {
          localStream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          for (const t of localStream.getTracks()) pc.addTrack(t, localStream);
        } catch (e) {
          log('Could not get mic', e);
        }
      }

      hangBtn.disabled = false;
    }

    function cleanup() {
      if (pc) {
        pc.close();
        pc = null;
      }
      if (remoteAudio) {
        remoteAudio.srcObject = null;
      }
      remoteState.textContent = 'no stream';
      hangBtn.disabled = true;
      callBtn.disabled = false;
    }
  </script>
</html>
